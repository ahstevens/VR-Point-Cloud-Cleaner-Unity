//uniform sampler2D sampler;
uniform int drawTexture;
uniform int drawMajorContours;
uniform int drawMinorContours;
uniform int drawGrid;


uniform float contourSizeMajor;
uniform float contourSizeMinor;
uniform float gridSize;

uniform float contourWidthMajor;
uniform float contourWidthMinor;
uniform float gridWidth;

uniform int drawRainbow;
uniform float rainbowMin;
uniform float rainbowMax;


uniform float textureScale;
varying vec3 P;


//new dynamic contours
uniform int enableDynamicContours;
uniform float majorContourLineWidth;
uniform float minorContourLineWidth;
uniform float minMajorContourValue;
uniform float majorContourSpacing;
//uniform int numMajorContourSpaces;
uniform float minorDynamicContourSpacing[255];



/*
 * 3D Perlin simplex noise
 * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05
 * You may use, modify and redistribute this code free of charge,
 * provided that my name and this notice appears intact.
 */

/*
 * "permTexture" is a 256x256 texture that is used for both the permutations
 * and the 2D and 3D gradient lookup. For details, see the main C program.
 * "simplexTexture" is a small look-up table to determine a simplex traversal
 * order for 3D and 4D simplex noise. Details are in the C program.
 * "gradTexture" is a 256x256 texture with 4D gradients, similar to
 * "permTexture" but with the permutation index in the alpha component
 * replaced by the w component of the 4D gradient.
 *
 * 3D simplex noise uses permTexture and simplexTexture.
 */
uniform sampler2D permTexture;
uniform sampler1D simplexTexture;

/*
 * To create offsets of one texel and one half texel in the
 * texture lookup, we need to know the texture image size.
 */
#define ONE 0.00390625
#define ONEHALF 0.001953125
// The numbers above are 1/256 and 0.5/256, change accordingly
// if you change the code to use another texture size.

/*
 * 3D simplex noise. Comparable in speed to classic noise, better looking.
 */
float snoise(vec3 point) {

// The skewing and unskewing factors are much simpler for the 3D case
#define F3 0.333333333333
#define G3 0.166666666667

  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in
 	float s = (point.x + point.y + point.z) * F3; // Factor for 3D skewing
  vec3 Pi = floor(point + s);
  float t = (Pi.x + Pi.y + Pi.z) * G3;
  vec3 P0 = Pi - t; // Unskew the cell origin back to (x,y,z) space
  Pi = Pi * ONE + ONEHALF; // Integer part, scaled and offset for texture lookup

  vec3 Pf0 = point - P0;  // The x,y distances from the cell origin

  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // To find out which of the six possible tetrahedra we're in, we need to
  // determine the magnitude ordering of x, y and z components of Pf0.
  // The method below is explained briefly in the C code. It uses a small
  // 1D texture as a lookup table. The table is designed to work for both
  // 3D and 4D noise, so only 8 (only 6, actually) of the 64 indices are
  // used here.
  float c1 = (Pf0.x > Pf0.y) ? 0.5078125 : 0.0078125; // 1/2 + 1/128
  float c2 = (Pf0.x > Pf0.z) ? 0.25 : 0.0;
  float c3 = (Pf0.y > Pf0.z) ? 0.125 : 0.0;
  float sindex = c1 + c2 + c3;
  vec3 offsets = texture1D(simplexTexture, sindex).rgb;
  vec3 o1 = step(0.375, offsets);
  vec3 o2 = step(0.125, offsets);

  // Noise contribution from simplex origin
  float perm0 = texture2D(permTexture, Pi.xy).a;
  vec3  grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;
  float t0 = 0.6 - dot(Pf0, Pf0);
  float n0;
  if (t0 < 0.0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * dot(grad0, Pf0);
  }

  // Noise contribution from second corner
  vec3 Pf1 = Pf0 - o1 + G3;
  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;
  vec3  grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;
  float t1 = 0.6 - dot(Pf1, Pf1);
  float n1;
  if (t1 < 0.0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * dot(grad1, Pf1);
  }
  
  // Noise contribution from third corner
  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;
  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;
  vec3  grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;
  float t2 = 0.6 - dot(Pf2, Pf2);
  float n2;
  if (t2 < 0.0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * dot(grad2, Pf2);
  }
  
  // Noise contribution from last corner
  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);
  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;
  vec3  grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;
  float t3 = 0.6 - dot(Pf3, Pf3);
  float n3;
  if(t3 < 0.0) n3 = 0.0;
  else {
    t3 *= t3;
    n3 = t3 * t3 * dot(grad3, Pf3);
  }

  // Sum up and scale the result to cover the range [-1,1]
  return 32.0 * (n0 + n1 + n2 + n3);
}



void main()
{

	if (drawTexture == 1)
	{
		//get noise intensity value here
		float n = snoise(vec3( (mod(P, textureScale)/textureScale)*256.0 ));
		gl_FragColor = gl_Color * vec4(0.90 + (0.10 * vec3(n, n, n)), 1.0);
	}
	else
	{
		gl_FragColor = gl_Color;
	}

	if (drawRainbow == 1) //extended banded
	{
		float stepSize = (rainbowMax - rainbowMin)/20.0;
		if (P.z <= (rainbowMin + stepSize))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.0, 1.0, 1.0);
		else if (P.z <= (rainbowMin + stepSize*2.0))
			gl_FragColor = gl_FragColor * vec4(0.84, 0.0, 0.93, 1.0);
		else if (P.z <= (rainbowMin + stepSize*3.0))
			gl_FragColor = gl_FragColor * vec4(0.69, 0.0, 0.88, 1.0);
		else if (P.z <= (rainbowMin + stepSize*4.0))
			gl_FragColor = gl_FragColor * vec4(0.33, 0.0, 0.62, 1.0);
		else if (P.z <= rainbowMin + (stepSize*5.0))
			gl_FragColor = gl_FragColor * vec4(0.18, 0.0, 0.91, 1.0);
		else if (P.z <= rainbowMin + (stepSize*6.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.18, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*7.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.55, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*8.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.78, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*9.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 1.0, 0.83, 1.0);
		else if (P.z <= rainbowMin + (stepSize*10.0))
			gl_FragColor = gl_FragColor * vec4(0.1, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*11.0))
			gl_FragColor = gl_FragColor * vec4(0.63, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*12.0))
			gl_FragColor = gl_FragColor * vec4(0.87, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*13.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.98, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*14.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.85, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*15.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.6, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*16.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.42, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*17.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*18.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.58, 0.58, 1.0);
		else if (P.z <= rainbowMin + (stepSize*19.0)) 
			gl_FragColor = gl_FragColor * vec4(1.0, 0.85, 0.85, 1.0);
		else 
			gl_FragColor = gl_FragColor * vec4(1.0, 1.0, 1.0, 1.0);
	}
	else if (drawRainbow == 2) //smoothed
	{
		float factor = 6.0-((P.z-rainbowMin)/(rainbowMax-rainbowMin))*6.0;
		int sextant = int(factor);
		float vsf = factor - float(sextant);
		float mid1 = vsf;
		float mid2 = 1.0 - vsf;
		if (sextant == 0)
			gl_FragColor = gl_FragColor * vec4(1.0, 0.0, mid2, 1.0);
		else if (sextant == 1)
			gl_FragColor = gl_FragColor * vec4(1.0, mid1, 0.0, 1.0);
		else if (sextant == 2)
			gl_FragColor = gl_FragColor * vec4(mid2, 1.0, 0.0, 1.0);
		else if (sextant == 3)
			gl_FragColor = gl_FragColor * vec4(0.0, 1.0, mid1, 1.0);
		else if (sextant == 4)
			gl_FragColor = gl_FragColor * vec4(0.0, mid2, 1.0, 1.0);
		else if (sextant == 5)
			gl_FragColor = gl_FragColor * vec4(mid1, 0.0, 1.0, 1.0);
	}
	else  if (drawRainbow == 3) //classic banded
	{
		float stepSize = (rainbowMax - rainbowMin)/14.0;
		if (P.z <= (rainbowMin + stepSize))
			gl_FragColor = gl_FragColor * vec4(0.33, 0.0, 0.62, 1.0);
		else if (P.z <= rainbowMin + (stepSize*2.0))
			gl_FragColor = gl_FragColor * vec4(0.18, 0.0, 0.91, 1.0);
		else if (P.z <= rainbowMin + (stepSize*3.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.18, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*4.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.55, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*5.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 0.78, 1.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*6.0))
			gl_FragColor = gl_FragColor * vec4(0.0, 1.0, 0.83, 1.0);
		else if (P.z <= rainbowMin + (stepSize*7.0))
			gl_FragColor = gl_FragColor * vec4(0.1, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*8.0))
			gl_FragColor = gl_FragColor * vec4(0.63, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*9.0))
			gl_FragColor = gl_FragColor * vec4(0.87, 1.0, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*10.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.98, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*11.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.85, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*12.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.6, 0.0, 1.0);
		else if (P.z <= rainbowMin + (stepSize*13.0))
			gl_FragColor = gl_FragColor * vec4(1.0, 0.42, 0.0, 1.0);
		else
			gl_FragColor = gl_FragColor * vec4(1.0, 0.0, 0.0, 1.0);
	}


	//gl_FragColor = gl_Color * texture2D(sampler, gl_TexCoord[0].st);

	if (enableDynamicContours == 1)
	{
		//major contours first
		float thisPZ = abs(P.z);

		float fMajor = abs(fract((thisPZ+(majorContourSpacing*0.5)) * majorContourSpacing)-(majorContourSpacing*0.5));
		float dfMajor = fwidth(thisPZ * majorContourSpacing);
		float valMajor = majorContourLineWidth * dfMajor;
		float gMajor = smoothstep(-valMajor, valMajor*0.95, fMajor) - smoothstep(valMajor, 0.0, fMajor);
		
		gl_FragColor = ( 0.333 * gl_FragColor) + (gMajor * gl_FragColor * 0.666);

		//minor contours as needed
		int contourSpace = int(floor((thisPZ-minMajorContourValue)/majorContourSpacing));
		//float spacingMinor = (majorContourSpacing*minorDynamicContourSpacing[contourSpace]);
	//	float spacingMinor = minorDynamicContourSpacing[contourSpace];
		//float spacingMinor = (majorContourSpacing*float(contourSpace));
		float spacingMinor = 1;
		if (float(contourSpace) < 2.0)
			spacingMinor = (majorContourSpacing*19);
		else if (float(contourSpace) < 3)
			spacingMinor = (majorContourSpacing*7);
		else if (float(contourSpace) < 4)
			spacingMinor = (majorContourSpacing*5);
		else if (float(contourSpace) < 7)
			spacingMinor = (majorContourSpacing*3);
		else
			spacingMinor = (majorContourSpacing*19);
		
		float lowerMajorValue = majorContourSpacing * floor(thisPZ/majorContourSpacing);
		float aboveLowerMajorValue = thisPZ - lowerMajorValue;

		float fMinor = abs(fract((thisPZ+(spacingMinor*0.5)) * spacingMinor)-0.5);
		float dfMinor = fwidth(thisPZ * spacingMinor);
		float valMinor = minorContourLineWidth * dfMinor;
		float gMinor = smoothstep(-valMinor, valMinor*0.95, fMinor) - smoothstep(valMinor, 0.0, fMinor);
		
		gl_FragColor = ( 0.75 * gl_FragColor) + (gMinor * gl_FragColor * 0.25);


	}
	else if (drawMajorContours == 1 && drawMinorContours == 1)
	{
		vec3 fMajor  = abs(fract (P * contourSizeMajor)-0.5);
		vec3 dfMajor = fwidth(P * contourSizeMajor);
		vec3 valMajor = contourWidthMajor*dfMajor;
		vec3 gMajor = smoothstep(-valMajor,(-valMajor*0.05) , fMajor) - smoothstep((valMajor*0.05),valMajor , fMajor);

		vec3 fMinor  = abs(fract (P * contourSizeMinor)-0.5);
		vec3 dfMinor = fwidth(P * contourSizeMinor);
		vec3 valMinor = contourWidthMinor*dfMinor;
		vec3 gMinor =  smoothstep(-valMinor,(-valMinor*0.05) , fMinor) - smoothstep((valMinor*0.05),valMinor , fMinor);

		if (gMajor.z > gMinor.z)
		{
			gl_FragColor = ( 0.50 * gl_FragColor) + ((1.0 - gMajor.z) * gl_FragColor * 0.5); 
			
		}
		else
		{
			gl_FragColor = ( 0.75 * gl_FragColor) + ((1.0 - gMinor.z) * gl_FragColor * 0.25); 
		}
	}
	else if (drawMajorContours == 1)
	{
		vec3 fMajor  = abs(fract (P * contourSizeMajor)-0.5);
		vec3 dfMajor = fwidth(P * contourSizeMajor);
		vec3 valMajor = contourWidthMajor*dfMajor;
		vec3 gMajor = smoothstep(-valMajor,(-valMajor*0.05) , fMajor) - smoothstep((valMajor*0.05),valMajor , fMajor);

		gl_FragColor = ( 0.50 * gl_FragColor) + ((1.0 - gMajor.z) * gl_FragColor * 0.5); 
	}
	else if (drawMinorContours == 1)
	{
		vec3 fMinor  = abs(fract (P * contourSizeMinor)-0.5);
		vec3 dfMinor = fwidth(P * contourSizeMinor);
		vec3 valMinor = contourWidthMinor*dfMinor;
		vec3 gMinor =  smoothstep(-valMinor,(-valMinor*0.05) , fMinor) - smoothstep((valMinor*0.05),valMinor , fMinor);

		gl_FragColor = ( 0.75 * gl_FragColor) + ((1.0 - gMinor.z) * gl_FragColor * 0.25); 
	}
	
	//add subtle XY grid lines
	if (drawGrid == 1)
	{
		vec3 fGrid  = abs(fract (P * gridSize)-0.5);
		vec3 dfGrid = fwidth(P * gridSize);
		vec3 valGrid = gridWidth*dfGrid;
		vec3 gGrid =  smoothstep(-valGrid,(-valGrid*0.05) , fGrid) - smoothstep((valGrid*0.05),valGrid , fGrid);

		if (gGrid.x > gGrid.y)
		{
			gl_FragColor = (gl_FragColor * 0.80) + ((1.0-gGrid.x) * gl_FragColor * 0.20);
		}
		else
		{
			gl_FragColor = (gl_FragColor * 0.80) + ((1.0-gGrid.y) * gl_FragColor * 0.20);
		}
	}

	gl_FragColor.a = gl_Color.a;

	//gl_FragDepth = gl_FragCoord.z;
	
}